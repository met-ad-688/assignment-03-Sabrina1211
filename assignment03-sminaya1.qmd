---
title: Assignment 03
author:
  - name: Sabrina Minaya Vasquez
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: '2025-09-24'
format:
  html:
    theme: cerulean
    toc: true
    toc-depth: 2
    code-overflow: wrap
  docx: default
  pdf: default
date-modified: today
date-format: long
execute:
  echo: true
  eval: true
  freeze: auto
jupyter: python3
---

# Import Packages 

```{python}
import pandas as pd
import plotly.express as px
import plotly.io as pio
pio.renderers.default = "svg"

from pyspark.sql import SparkSession
import re
import numpy as np
import plotly.graph_objects as go

from pyspark.sql.functions import col, split, explode, regexp_replace, transform, when
from pyspark.sql import functions as F
from pyspark.sql.functions import col, monotonically_increasing_id

# Set random seed
np.random.seed(42)

# Change Plotly renderer for notebooks
pio.renderers.default = "notebook"

```

# Plotly Templete

```{python}

pio.templates["nike"] = go.layout.Template(
    # LAYOUT
    layout = {
        # Fonts
        # Note - 'family' must be a single string, NOT a list or dict!
        'title':
            {'font': {'family': 'HelveticaNeue-CondensedBold, Helvetica, Sans-serif',
                      'size':30,
                      'color': '#333'}
            },
        'font': {'family': 'Helvetica Neue, Helvetica, Sans-serif',
                      'size':16,
                      'color': '#333'},
        # Colorways
        'colorway': ['#ec7424', '#a4abab'],
        # Keep adding others as needed below
        'hovermode': 'x unified'
    },
    # DATA
    data = {
        # Each graph object must be in a tuple or list for each trace
        'bar': [go.Bar(texttemplate = '%{value:$.2s}',
                       textposition='outside',
                       textfont={'family': 'Helvetica Neue, Helvetica, Sans-serif',
                                 'size': 20,
                                 'color': '#FFFFFF'
                                 })]
    }
)

```

# Load Dataset

```{python}

#| eval: true
#| echo: true
#| fi-aling: center

# Initialize Spark Session
spark = SparkSession.builder.appName("LightcastData").getOrCreate()

# Load Data
df = spark.read.option("header", "true").option("inferSchema", "true").option("multiLine","true").option("escape", "\"").csv("/home/ubuntu/assignment-03-Sabrina1211/data/lightcast_job_postings.csv")

# Show Schema and Sample Data
#print("---This is Diagnostic check, No need to print it in the final doc---")

#df.printSchema() # comment this line when rendering the submission
#df.show(5)

```

# Data Preparation

```{python}
# Step 1: Casting Salary and experience columns
df = df.withColumn("SALARY", col("SALARY").cast("float")) \
       .withColumn("SALARY_FROM", col("SALARY_FROM").cast("float")) \
       .withColumn("SALARY_TO", col("SALARY_TO").cast("float")) \
       .withColumn("MIN_YEARS_EXPERIENCE", col("MIN_YEARS_EXPERIENCE").cast("float")) \
       .withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float"))


# Step 2: Computing medians for salary columns

def compute_median(sdf, col_name):
    q = sdf.approxQuantile(col_name, [0.5], 0.01)
    return q[0] if q else None

median_from = compute_median(df, "SALARY_FROM")
median_to = compute_median(df, "SALARY_TO")
median_salary = compute_median(df, "SALARY")

print("Medians:", median_from, median_to, median_salary)

# Step 4: Imputing missing salaries, but no experience
df = df.fillna({
     "SALARY_FROM": median_from,
     "SALARY_TO": median_to,
   
})

# Step 5: Computing Average Salary
df = df.withColumn("Average_Salary", (col("SALARY_FROM") + col("SALARY_TO")) /2)

# Step 6: Selecting required columns
export_cols = [
    "EDUCATION_LEVELS_NAME",
    "REMOTE_TYPE_NAME",
    "MAX_YEARS_EXPERIENCE",
    "Average_Salary",
    "SALARY",
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME"
]

df_selected = df.select(*export_cols)

# Step 7: Saving to csv
pdf = df_selected.toPandas()
pdf.to_csv("./data/lightcast_cleaned.csv", index=False)

print("Data cleaning complete. Rows retained:", len(pdf))

```


# Salary Distribution Employment Type

```{python}

# Filter out missing or zero salary values
pdf = (
    df.select("EMPLOYMENT_TYPE_NAME", col("SALARY").cast("double").alias("SALARY"))
      .filter( (col("SALARY").isNotNull()) & (col("SALARY") > 0) )
      .toPandas()
)

# Clean labels
pdf["EMPLOYMENT_TYPE_NAME"] = (
    pdf["EMPLOYMENT_TYPE_NAME"].astype("string").fillna("Unknown")
      .str.replace(r"[^\x00-\x7F]+", "", regex=True).str.strip()
)

# Sort by median salary
sorted_employment_types = (
    pdf.groupby("EMPLOYMENT_TYPE_NAME")["SALARY"].median()
       .sort_values(ascending=False).index
)
pdf["EMPLOYMENT_TYPE_NAME"] = pd.Categorical(pdf["EMPLOYMENT_TYPE_NAME"],
                                             categories=sorted_employment_types,
                                             ordered=True)

# --- box plot: show outliers only ---
fig = px.box(
    pdf,
    x="EMPLOYMENT_TYPE_NAME",
    y="SALARY",
    title="Salary Distribution by Employment Type",
    color_discrete_sequence=["#EF553B"],
    points="outliers"  # ← key change
)

fig.update_layout(
    xaxis=dict(title="Employment Type", categoryorder="array",
               categoryarray=sorted_employment_types.tolist(),
               tickfont=dict(size=18)),
    yaxis=dict(title="Salary (K $)", range=[0, 500000],
               tickvals=[0, 50_000, 100_000, 150_000, 200_000, 250_000, 300_000, 350_000, 400_000, 450_000, 500_000],
               ticktext=["0","50K","100K","150K","200K","250K","300K","350K","400K","450K","500K"]),
    font=dict(family="Arial", size=16),
    plot_bgcolor="white",
    paper_bgcolor="white",
    showlegend=False,
    height=500, width=850
)

fig.show()
fig.write_html("output/DistributionEmploymentType.html")
fig.write_image("output/DistributionEmploymentType.svg", width=850, height=500, scale=1)

```


# Salary Distribution by Industry

```{python}
#| eval: false
#| echo: true
#| fig-align: center

pdf = df.select("NAICS2_NAME", "SALARY").toPandas()

fig = px.box(
    pdf,
    x="NAICS2_NAME",
    y="SALARY",
    title="Salary Distribution by Industry",
    color_discrete_sequence=["#EF553B"]
)

fig.update_layout(template="nike")  # change to "plotly_white" if this template isn't available

# rotate x-axis labels for readability
fig.update_xaxes(tickangle=45)

fig.show()

fig.write_html("output/DistributionIndustry.html")
fig.write_image("output/DistributionIndustry.svg", width=850, height=500, scale=1)

```

 # Salary Analysis by ONET Occupation Type (Bubble Chart)

 ```{python}
#| eval: false
#| echo: false

# Step 1: Spark SQL - Median salary and job count per TITLE_NAME
salary_analysis = spark.sql("""
SELECT
  LOT_OCCUPATION_NAME AS Occupation_Name,
  PERCENTILE(SALARY, 0.5) AS Median_Salary,
  COUNT(*) AS Job_Postings
FROM job_postings
GROUP BY LOT_OCCUPATION_NAME
ORDER BY Job_Postings DESC
LIMIT 10
""")

# Step 2: Convert to Pandas DataFrame
salary_pd = salary_analysis.toPandas()
salary_pd.head()

fig = px.scatter(
    salary_pd,
    x="Occupation_Name",
    y="Median_Salary",
    size="Job_Postings",
    title="Salary Analysis by LOT Occupation Type (Bubble Chart)",
    labels={
        "Occupation_Name": "LOT Occupation",
        "Median_Salary": "Median Salary",
        "Job_Postings": "Number of Job Postings",
    },
    hover_name="Occupation_Name",
    size_max=60,
    width=1000,
    height=600,
    color="Job_Postings",
    color_continuous_scale="Plasma",
)
# Step 4: Layout customization
fig.update_layout(
    font_family="Arial",
    font_size=14,
    title_font_size=25,
    xaxis_title="LOT Occupation",
    yaxis_title="Median Salary",
    plot_bgcolor="white",
    xaxis=dict(
        tickangle=-45,
        showline=True,
        linecolor="black",
    ),
    yaxis=dict(
        showline=True,
        linecolor="black",
    ),
)

# Step 5: Show and export
fig.show()
fig.write_html("output/salaryAnalsis.html")
fig.write_image("output/salaryAnalysis.svg", width=1000, height=600, scale=1)
 ```

# Salary by Education Level

```{python}
#| eval: true
#| echo: true

# ---- Prep: group education levels, clean & filter ----
from pyspark.sql.functions import col, when

# Defining education level groupings
lower_deg  = ["Bachelor's", "Associate", "GED", "No Education Listed", "High school"]
higher_deg = ["Master's degree", "PhD or professional degree"]

# Add EDU_GROUP column
df = df.withColumn(
    "EDU_GROUP",
    when(
        col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in lower_deg])),
        "Bachelor's or lower",
    )
    .when(
        col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in higher_deg])),
        "Master's or PhD",
    )
    .otherwise("Other")
)

# Cast to numeric
df = df.withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float"))
df = df.withColumn("Average_Salary",      col("Average_Salary").cast("float"))

# Keep non-null & positive values
df = df.filter(
    col("MAX_YEARS_EXPERIENCE").isNotNull()
    & col("Average_Salary").isNotNull()
    & (col("MAX_YEARS_EXPERIENCE") > 0)
    & (col("Average_Salary") > 0)
)

# Keep just the two education groups
df_filtered = df.filter(col("EDU_GROUP").isin("Bachelor's or lower", "Master's or PhD"))

# Convert to pandas for plotting
df_pd = df_filtered.toPandas()

# ---- Plot: Experience vs Salary by Education Group ----
import os
import plotly.express as px

fig1 = px.scatter(
    df_pd,
    x="MAX_YEARS_EXPERIENCE",
    y="Average_Salary",
    color="EDU_GROUP",
    title="Experience vs Salary by Education Group",
    labels={
        "MAX_YEARS_EXPERIENCE": "Years of Experience",
        "Average_Salary": "Average Salary (USD)",
        "EDU_GROUP": "Education Group",
    },
)

fig1.update_layout(
    plot_bgcolor="#f9f9f9",   # light grey chart background
    paper_bgcolor="#FFF5DC",  # soft frame
    font=dict(family="Segoe UI", size=14),
    title_font=dict(size=22),
    xaxis_title="Years of Experience",
    yaxis_title="Average Salary (USD)",
    legend_title="Education Group",
    hoverlabel=dict(bgcolor="white", font_size=13, font_family="Arial"),
    margin=dict(t=70, b=60, l=60, r=60),
    xaxis=dict(
        gridcolor="lightgrey",
        tickmode="linear",
        dtick=1,               # show every integer year
    ),
    yaxis=dict(gridcolor="lightgrey"),
)

fig1.show()

# Save HTML (static image export requires kaleido)
fig1.write_html("output/SalaryEducationLevel")

```

# Salary by Remote Work Type

```{python}


```